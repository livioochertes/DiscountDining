1) Alege modelul corect: server-ledger + intents

RegulÄƒ: nici chelnerul, nici clientul nu â€œmutÄƒ baniâ€. Doar serverul mutÄƒ unitÄƒÈ›i de credit Ã®n ledger.

Ledger (double-entry, atomic)
	â€¢	UserWallet (debit)
	â€¢	RestaurantWallet (credit)
	â€¢	EatOffFees (credit, dacÄƒ e cazul)
	â€¢	opÈ›ional Escrow/Clearing

Totul Ã®n minor units (bani Ã®ntregi: bani/centime), fÄƒrÄƒ float.

â¸»

2) Top-up prin Stripe: sigur, dar fÄƒ-l â€corectâ€

Flux recomandat:
	1.	Client â†’ server: POST /topups (sumÄƒ, monedÄƒ)
	2.	Server â†’ Stripe: creeazÄƒ PaymentIntent (client_secret)
	3.	Client confirmÄƒ Ã®n Stripe SDK
	4.	Webhook Stripe (singura sursÄƒ de adevÄƒr) â†’ server marcheazÄƒ topup â€œsucceededâ€
	5.	Server posteazÄƒ intrarea Ã®n ledger: TopUpCredit

ğŸ”‘ Important:
	â€¢	nu credita contul la â€œsuccess pe clientâ€; numai la webhook.
	â€¢	foloseÈ™te idempotency keys la Stripe + la server.

â¸»

3) Cheltuirea Ã®n restaurant: â€œproof-of-presenceâ€ + anti-replay

Cea mai sigurÄƒ variantÄƒ: QR one-time + session

Ãn restaurant, Device B afiÈ™eazÄƒ un QR care conÈ›ine un token scurt, semnat de server.

Flow:
	1.	Chelner/POS (Device B) â†’ server: POST /checkin-sessions
	â€¢	restaurant_id, table_id (opÈ›ional), amount_hint (opÈ›ional)
	2.	Server rÄƒspunde cu session_id + qr_token (expirÄƒ Ã®n 30â€“120 sec)
	3.	Client (Device A) scaneazÄƒ QR â†’ trimite la server: POST /payment-intents
	â€¢	session_id, amount, tip (opÈ›ional)
	4.	Server face risk checks + freeze fonduri (hold)
	5.	Client confirmÄƒ (PIN/biometric Ã®n app)
	6.	Server finalizeazÄƒ tranzacÈ›ia: POST /payment-intents/{id}/confirm

âœ… Avantaje:
	â€¢	Device B nu poate inventa locaÈ›ii
	â€¢	tokenul expirÄƒ rapid, nu se poate re-folosi
	â€¢	chiar dacÄƒ GPS e slab, QR â€œbateâ€ tot

â¸»

4) Device B: telefon chelner vs POS â€” ce e mai securizat?

âœ… Cel mai securizat: POS / tabletÄƒ dedicatÄƒ restaurantului
	â€¢	cont â€œrestaurant deviceâ€ dedicat
	â€¢	device managed (mai stabil, mai puÈ›in risc de malware personal)

Telefon chelner: ok, dar impune reguli

DacÄƒ alegi telefon chelner:
	â€¢	autentificare staff + role-based access (RBAC)
	â€¢	device binding (device_id) + limitÄƒri
	â€¢	revocare instant dacÄƒ pleacÄƒ din firmÄƒ

Recomandarea mea:
â¡ï¸ Pentru securitate maximÄƒ: POS/tabletÄƒ restaurant ca Device B (sau minimum â€œRestaurant Admin deviceâ€), iar chelnerii au acces limitat.

â¸»

5) SemnÄƒturi + idempotency pe requesturile sensibile

Pe toate endpoint-urile de â€œmoney movementâ€:
	â€¢	X-Request-Id (UUID) = idempotency
	â€¢	X-Timestamp + X-Nonce (anti replay)
	â€¢	X-Signature (HMAC cu secret de device stocat Ã®n Keychain/Keystore)

Server verificÄƒ:
	â€¢	timestamp Ã®n fereastrÄƒ (ex: 2 minute)
	â€¢	nonce nefolosit
	â€¢	request-id neprocesat

Asta opreÈ™te:
	â€¢	replay
	â€¢	dublÄƒri
	â€¢	modificÄƒri prin proxy

â¸»

6) â€Hold â†’ Captureâ€ pentru credit intern (anti-fraud / anti-dispute)

CÃ¢nd clientul iniÈ›iazÄƒ plata:
	1.	Hold: scazi din â€œavailableâ€, pui Ã®n â€œreservedâ€ (ledger event Reserve)
	2.	Confirmare finalÄƒ â†’ Capture (Capture)
	3.	Timeout / cancel â†’ Release

Asta Ã®È›i permite:
	â€¢	sÄƒ eviÈ›i cheltuiri paralele
	â€¢	sÄƒ gestionezi offline / pierdere conexiune
	â€¢	sÄƒ ai UX bun (â€œse proceseazÄƒâ€)

â¸»

7) Risk checks (simple, dar eficiente)

La confirmare:
	â€¢	wallet balance suficient
	â€¢	session valid + ne-expirat + restaurant match
	â€¢	device A & B â€œfreshâ€ (nu token vechi)
	â€¢	rate limits (ex: max 3 Ã®ncercÄƒri/minut)
	â€¢	â€velocityâ€ check: prea multe tranzacÈ›ii rapide = flag

OpÈ›ional (nice-to-have):
	â€¢	iOS DeviceCheck / App Attest
	â€¢	Android Play Integrity API
(ajutÄƒ contra emulator/root, dar nu te baza doar pe ele)

â¸»

8) Decontare cÄƒtre restaurant (payout)

SeparÄƒ complet:
	â€¢	ledger intern (instant)
	â€¢	payout (zilnic/sÄƒptÄƒmÃ¢nal)

Payout-ul Ã®l faci dintr-un job server:
	â€¢	calculezi net (minus fee, refunds)
	â€¢	transfer bancar / Stripe Connect (dacÄƒ alegi) / alt PSP

â¸»

9) Ce faci dacÄƒ e semnal slab?
	â€¢	Flow-ul QR + server e â€œonline requiredâ€ pentru securitate.
	â€¢	DacÄƒ vrei fallback:
	â€¢	permiÈ›i â€œoffline draftâ€ pe Device B, dar NU finalizezi fÄƒrÄƒ confirmare server.
	â€¢	clientul poate vedea â€œpendingâ€, iar la reconectare se finalizeazÄƒ.

Securitate maximÄƒ = nu finalizezi money movement offline.

â¸»

ConfiguraÈ›ia pe care È›i-aÈ™ recomanda-o pentru EatOff (foarte solidÄƒ)
	â€¢	Top-up: Stripe PaymentIntent + webhook creditare
	â€¢	Pay in restaurant: QR one-time (server-issued) + PaymentIntent intern (hold/capture)
	â€¢	Device B: POS/tabletÄƒ restaurant (preferat) + chelnerii cu permisiuni limitate
	â€¢	Server: ledger double-entry + idempotency + HMAC signatures